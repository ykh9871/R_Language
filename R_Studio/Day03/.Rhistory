if (i %% 3 != 0){
next #print()를 실행하지 않고while문의 처음으로 감
}
print(i)
}
### while문 에서 next 사용
i <- 0
while (i<= 15) {
i <- i + 1
if (i %% 3 != 0){
next #print()를 실행하지 않고while문의 처음으로 감
}
print(i)
}
### repeat 사용 예
a <- 11
repeat{
print(a)
if(a>=20){
break
}
a <- a+1
}
# 2.연산
## 1. 벡터연산
### 벡터 연산은 벡터 또는 리스트를 한번에 연산하는 것을 의미
### 벡터 간의 연산도 가능
a <- c(1,3,5,7,9)
a + 2
#벡터간 연산
a <- c(1,3,5,7,9)
a + a
a==a
a==c(1,3,5,7,7)
source("C:/Yoongit/R_Language/R_Studio/Day01/R_basic2.R", echo=TRUE)
### 벡터 연산시 개수가 다를 경우 경고 발생
x <- c(1,3,5,7,9)
y <- c(2,2,2,2,2,2,2,2)
x+y
### 데이터에 NA 포함된 경우, 결과가 항상 NA로 변경됨
### 따라서 NA처리 함수 필요
### NA는 누락 된 값 지시자를 포함하는 길이 1의 논리 상
### 데이터 처리 함수들 없이 SQL문을 이용하여 데이터를 편리하게 조작할 수 있음
### 패키지 설치
install.packages("sqldf")
library(sqldf)
### SQL문을 이용해 Orange데이터의 Tree 종류 검색
sqldf("select distinct Tree from Orange")
### Orange데이터 중 Tree가 1인 age의 평균 구하기
sqldf("select avg([age]) from Orange where Trree =1")
### Orange데이터 중 Tree가 1인 age의 평균 구하기
sqldf("select avg([age]) from Orange where Tree =1")
source("~/.active-rstudio-document", echo=TRUE)
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[.1:4], i, function(row){printr(row)})
source("~/.active-rstudio-document", echo=TRUE)
install.packages("sqldf")
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[.1:4], i, function(row){printr(row)})
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[.1:4], i, function(row){printr(row) })
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[.1:4], i, function(row){printr(row) }))
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[.1:4], 1, function(row){printr(row) }))
apply(iris, 1, function(row) {print(row})
apply(iris, 1, function(row) {print(row)})
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[,1:4], 1, function(row){printr(row) }))
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[,1:4], 1, function(row){printr(row) })
#### adply()는 배열(a)를 받아 데이터 프레임(d)를 반환하는 함수
#### 입력이 반드시 배열일 필요는 없음
#### apply()를 사용해도 되지만, 행방향으로 처리할 때 각 열에 서로
#### 다른 데이터 타입이 섞여있을 경우 예상치 못한 타입 변환 발생 가능성이 있음
#### 예
apply(iris[,1:4], 1, function(row){print(row) })
apply(iris, 1, function(row) {print(row)})
#### plyr패키지 설치
install.packages("plyr")
library(plyr)
#### adply()를 사용해 Petal.Length가 5.0 이상이고 Species가 setosa인지 여부 확인후 ,새로운 컬럼 V1에 기록
adply(iris, 1, function(x) {x$Petal.Length >= 1.5 & x$Species == "setosa"})
#### ddply()는 데이터 프레임(d)을 입력으로 받아 데이터 프레임(d)를 내보내는 함수
#### iris데이터에서 Petal.Length의 평균을 Species 별로 계산하는 예
#### 출력시 컬렴명은 Swmean으로 지정
#### 데이터를 그룹짓는 변수는.()안에 기록
ddply(iris, .(Species), function(x) {data.frame(Swmean = mean(x$Petal.Length))})
### reshape2
### 데이터의 모양을 바꾸거나 그룹별 요약 값을 계산 하는 패키지
### melt(), cast()함수가 대표적
install.packages("reshape2")
library(reshape2)
#### 식별자(id), 측정변수(variable), 측정치(value)형태로 데이터를 제공하는 함수
#### french_fries데이터 프레임
#### 실험 수행시간, 오일 종류, 대상 프렌치프라이, 반복실험 횟수
#### melt()이용한 변수 수행 예
head(french_fries)
m <- melt(id=1:4, french_fries)
head(m)
#### 2.cast()
#### 얻고자 하는 데이터 타입에 따라 dcast(), acast()로 구분
#### dcast() : 데이터 프레임을 결과로 반환
#### acast() : 벡터, 행렬, 배열을 반환
#### dcast(data, fomular, fun.aggregate) : 결과로 데이터 프레임 반환
#### indetical() : 두 데이터가 완전한 객체인지 판별하는 함수
smiths
m <- melt(id=1:2, smiths)
m
x <- dcast(m, subject + time ~ ...)
x
identical (x, smiths)
## 패키지 설치
install.packages("data.table")
library(data.table)
## 데이터 프레임을 만드는 것과 동일한 문법으로 생성
x <- data.table(a = c(10,20,30), b = c("A","B","C"))
x
## 데이터 테이블 생성하기
Orange_table <- as.data.table(Orange)
Orange_table
## 데이터 테이블의 목록 열람하기
tables()
### 데이터 테이블의 데이터는 [행, 표현식, 옵션] 형태로 접근
DT <- as.data.table(mtcars)
DT
DT[1,]
DT[DT$disp >=160.]
### [행,표현식,옵션]의 두번째 인자에는 컬럼명을 그대로 적거나 또는 컬럼명에 대한 표현식을 적는다.
DT <- as.data.table(mtcars)
DT
DT[1, mpg]
### 여러 컬름을 선택할 때는 list()안에 컬럼 나열
DT <-as.data.table(mtcars)
DT
DT[1, list(mpg, cy1, disp, hp)]
DT[1, list(mpg, cyl, disp, hp)]
### 컬럼명을 그대로 사용해 연산 수행 가능
DT[, (max(mpg) - min(mpg))]
DT[, mean(mpg)]
DT[, max(mpg)]
DT[, min(mpg)]
DT[, (max(mpg) - min(mpg))]
### 세번째 인자에는 데이터를 그룹지을 변수 지정
DT[, mean(disp), by="gear"]
### DT2변수에 데이터 테이블 생성 후 x의 평균을 y, z 컬럼에 따라 계산한 예
DT2 <- data.table(x = c(10,20,30,40,50), y = c("a","a","a","b","b"),
z = c("c","c","d","d","d"))
DT2
DT2[, mean(x), by = "y,z"]
### 2.key를 사용한 탐색
### 데이터 프레임에서 특정 컬럼에 특정 값이 들어있는 행을 찾는 작업은 모든 행의 값을 하나하나 검토하는 방식
### 데이터 양이 많고 검색 작업의 횟수가 많다면 수행시간 길어짐
### setkey()를 사용해 색인을 만들어 두었다가 검색 시 사용
### J(컬럼명1, 컬럼명2, ...)형태로 키를 나열해 데이터 검색
DF <- data.frame(x = runif(1300000), y = rep(LETTERS, each=50000))
str(DF)
head(DF)
system.time(x <- DF[DF$y=="D",])
DT <-as.data.table(DF)
setkey(DT, y)
system.time(x <- DT[J("D"), ])
### 데이터 테이블 dT1, DT2에서 DT1[DT2, 표현식
### DT1에서 DT2에 대응되는 데이터를 찾는 방식으로 병합
### 대응하지 않는 행이 없으면 z에 NA값이 반환
DT1 <- data.table(x = runif(1300000), y = rep(LETTERS, each = 50000))
DT2 <- data.table(y = c("a","b","c"), z = c("aaa","bbb","ccc"))
setkey(DT1, y)
DT1[DT2,]
### 데이터 테이블 dT1, DT2에서 DT1[DT2, 표현식
### DT1에서 DT2에 대응되는 데이터를 찾는 방식으로 병합
### 대응하지 않는 행이 없으면 z에 NA값이 반환
DT1 <- data.table(x = runif(1300000), y = rep(LETTERS, each = 50000))
DT2 <- data.table(y = c("A","B","C"), z = c("aaa","bbb","ccc"))
setkey(DT1, y)
DT1[DT2,] # DT1으로부터 y값이 A,B,C인 행을 찾아 병합
### 반면 DT2[Dt1, ]은 1300000개의 행을 DT2로부터 검색하므로 결과가 총 1300000행
### 대응하지 않는 행이 없으면 z에 NA값이 반환
setkey(DT2, y)
DT2[DT1,]
### DT1[DT2, ]와 데이터 프레임으로 merge하여 합칠 때 시간 비교
### 색인을 이용한 데이터 테이블의 합병 과정이 더 빠른 처리 시간을 가짐
DT1 <- data.table(x = runif(1300000), y = rep(LETTERS, each = 50000))
DT2 <- data.table(y = c("A","B","C"), z = c("aaa","bbb","ccc"))
setkey(DT1, y)
system.time(DT1[DT2, ])
system.time(DT1[DT2, ])
DF1 <- as.data.frame(DT2)
DF1 <- as.data.frame(DT1)
DF2 <- as.data.frame(DT2)
system.time(merge(DF1, DF2))
### 1.foreach
### apply(), for()를 대채할 수 있는 루프 함수
### foreach는 apply 함수들, for문 등을 대체할 수 있는 루프문을 위한 함수
### for문과의 가장 큰 차이는 반환값이 있고, %do% 문을 사용해 블록을 지정
install.packages("foreach")
library(foreach)
### 1에서 3까지 숫자를 루프를 돌면서 %do%안에서 반환하면 1부터 3까지의 숫자를 담은 리스트 반환.
### .combine에는 연산자를 지정하여 사용 가능
foreach(i=1:3) %do% {return(i)}
foreach(i=1:5, .combine = "*") %do% {return(i)}
foreach(i=1:5, .combine = "+") %do% {return(i)}
## plot()함수 이용
methods("plot")
### Orange데이터의 나이와 둘레를 산점도로 표현
plot(Orange$age, Orange$circumference)
### plot(X,Y, xlab, ylab): x,y 축 이름 지정
plot(Orange$age, Orange$circumference, xlab = "Orange Tree Age", ylab = "Ornage Tree Circumference")
### main 옵션은 그래프의 제목을 지정
plot(Orange$age, Orange$circumference, xlab = "Orange Tree Age", ylab = "Orange Tree Circumference", main = "Orange")
### pch 옵션은 점의 모양을 지정
### 숫자 지정 : 미리 지정된 심볼 사용
### 문자 지정 : 해당 문자를 사용해 점으로 표시
plot(Orange$age, Orange$circumference, xlab = "Orange Tree Age",
ylab = "Orange Tree Circumference", main = "Orange", pch = 20)
plot(Orange$age, Orange$circumference, xlab = "Orange Tree Age",
ylab = "Orange Tree Circumference", main = "Orange", pch = "+")
### cex 옵션은 점의 크기를 지정
### 기본값은 1이며 , cex가 작을수록 점의 크기가 작아짐
plot(Orange$age, Orange$circumference, xlab = "Orange Tree Age",
ylab = "Orange Tree Circumference", main = "Orange", pch = "+", cex = 2)
ylab = "Orange Tree Circumference", main = "Orange", cex = 2, col = #ff0000)
ylab = "Orange Tree Circumference", main = "Orange", cex = 2, col = #ff0000)
### col은 표현되는 산점도의 색을 지정
### 색상은 점,선,등 모두가 해당됨
plot(Orange$age, Orange$circumference, xlab = "Orange Tree Age",
ylab = "Orange Tree Circumference", main = "Orange", cex = 2, col = "#ff0000")
min(Orange$age)
max(Orange$age)
min(Orange$circumference)
max(Orange$circumference)
min(Orange$circumference)
### 앞서 구한 Age, Circumference의 범위 중 범위를 축소하여 산점도 출력
### (Age : 500~1200, Circumference : 50 ~ 150)
plot(Orange$age, Orange$circumference, xlab = "Orange Tree Age",
ylab = "Orange Tree Circumference", main = "Orange", cex = 2, col = "#ff0000",
xlim = c(500, 1200), ylim = c(50, 150))
### type중 자주 사용하는 값으로는 p(점), l(선), b(점과 선 모두),
### 0(점과 선을 중첩하여 그림), n(아무것도 그리지 않음)
### b와 o는 유사해 보이지만, b는 점과 선이 만나는 점에서는 점 또는 선 중 하나만 보인다.
### 반면 o 는 점 그래프를 그리고 그 위에 선 그래프를 중첩하여 그린다.
### n은 데이터를 그리지는 않지만 새로운 그래프를 초기화 할 때 사용
plot(Orange$age, Orange$circumference, cex = 2)
plot(Orange$age, Orange$circumference, cex = 2, type = "l")
plot(Orange$age, Orange$circumference, cex = 2, type = "b")
plot(Orange$age, Orange$circumference, cex = 2, type = "o")
plot(Orange$age, Orange$circumference, cex = 2, type = "n")
plot(Orange$age, Orange$circumference, cex = 2, type = "n", main = "type=n")
plot(Orange$age, Orange$circumference, cex = 2, type = "l", main = "type=l")
plot(Orange$age, Orange$circumference, cex = 2, type = "b", main = "type=b")
plot(Orange$age, Orange$circumference, cex = 2, type = "o", main = "type=o")
plot(Orange$age, Orange$circumference, cex = 2, type = "n", main = "type=n")
### type = o그래프의 경우 오렌지 나무의 나이에 따른 둘레 변화를 보기가 어려움
### 이를 해결하기 위해 tapply() 함수를 이용하여 각 나이마다 평균 둘레를 tapply를 사용해 plot()으로 그림
plot(tapply(Orange$age, Orange$circumference, mean), cex = 2, type = "o")
### 선 유형을 지정하는 옵션
### lty는 숫자 또는 문자열로 지정할 수 있다.
### 숫자일 경우 0=그리지 않음, 1=실선(기본값), 2=대시(-)로 표시,
### 3 = 점, 4 = 점과 대시, 5 긴 대시, 6 두개의 대시
### 문자열로 지정할 경우 "blank", "solid", "dashed", "dotted", "dotdash", "longdash". "twodash"에 해당한다.
### 앞서 그래프를 type = l로 그리고 , lty="dashed"를 옵션을 주어 대시로 선의 모양을 지정한 예
plot(tapply(Orange$age, Orange$circumference, mean), cex = 2, type="o",
xlab = "Orange Tree Age", ylab = "Orange Tree Circumference", lty="dashed")
### plot()으로 그래프를 그리면 매번 새로운 창에 출력
### par() : 연관된 그래프 다수를 한번에 출력하는 함수
paroption <- par(mfrow = c(2, 2))
plot(tapply(Orange$age, Orange$circumference, mean), cex = 2, type="o",
xlab = "Orange Tree Age", ylab = "Orange Tree Circumference", lty="dashed", main = "Orange1")
plot(tapply(Orange$age, Orange$circumference, mean), cex = 2, type="o",
xlab = "Orange Tree Age", ylab = "Orange Tree Circumference", lty="dashed", main = "Orange2")
plot(tapply(Orange$age, Orange$circumference, mean), cex = 2, type="o",
xlab = "Orange Tree Age", ylab = "Orange Tree Circumference", lty="dashed", main = "Orange3")
plot(tapply(Orange$age, Orange$circumference, mean), cex = 2, type="o",
xlab = "Orange Tree Age", ylab = "Orange Tree Circumference", lty="dashed", main = "Orange4")
par(paroption)
### 1.점(point)
### points() : 점을 그리는 함수, plot()은 매번 새로운 그래프가 그려지지만 points()는 추가로 그려줌
plot(iris$Sepal.Length, iris$Sepal.Width, cex=2, pch=20)
points(iris$Petal.Length, iris$Petal.Width, cex=2. pch="+", col="#FF0000")
points(iris$Petal.Length, iris$Petal.Width, cex=2, pch="+", col="#FF0000")
### lines(x,y,...) : 연결된 선들을 그래프에 추가하여 그림
### lowess() : 데이터를 설명하는 일종의 추세선(회귀분석)
plot(cars)
lines(lowess(cars))
### abline()함수의 파라미터
### h는 수평의 horizontal, v는 수직의vertical를 뜻함
abline(h = mean(cars$dist), lty=2)
abline(v = mean(cars$speed), lty=2)
### lines(x,y,...) : 연결된 선들을 그래프에 추가하여 그림
### lowess() : 데이터를 설명하는 일종의 추세선(회귀분석)
plot(cars)
lines(lowess(cars))
### abline()함수의 파라미터
### h는 수평의 horizontal, v는 수직의vertical를 뜻함
abline(h = mean(cars$dist), lty=2)
abline(v = mean(cars$speed), lty=2)
### curve() : 주어진 표현식에 대해 곡선을 그리는 함수
### curve(표현식, 구간시작점, 구간끝점)
curve(sin, 0, 2*pi)
### text() : 그래프에 문자열을 그리는데 사용하는 함수
### pos는 텍스트의 좌표를 지정
### 1:좌표의 하단, 2:좌표의 좌측, 3:좌표의 상단, 4:좌표의 우측
### adj는 텍스트의 위치를 지정
### (0,0):우측 상단, (0,1):우측 하단, (1,0):좌측 상단, (1,1):좌측 하단
### pos, adj를 동시에 지정하면 pos가 우선
rm(list=ls())
### text() : 그래프에 문자열을 그리는데 사용하는 함수
### pos는 텍스트의 좌표를 지정
### 1:좌표의 하단, 2:좌표의 좌측, 3:좌표의 상단, 4:좌표의 우측
### adj는 텍스트의 위치를 지정
### (0,0):우측 상단, (0,1):우측 하단, (1,0):좌측 상단, (1,1):좌측 하단
### pos, adj를 동시에 지정하면 pos가 우선
plot(1:6 ,1:6)
text(2,1, "Hi")
text(3,2, "Go")
text(4,4 "00", adj=c(0,0))
text(4,4 "00", adj=c(0,0))
text(4,4 "00", adj=c(0,0)
text(4,4, "00", adj=c(0,0)
text(4,4, "01", adj=c(0,1))
### text() : 그래프에 문자열을 그리는데 사용하는 함수
### pos는 텍스트의 좌표를 지정
### 1:좌표의 하단, 2:좌표의 좌측, 3:좌표의 상단, 4:좌표의 우측
### adj는 텍스트의 위치를 지정
### (0,0):우측 상단, (0,1):우측 하단, (1,0):좌측 상단, (1,1):좌측 하단
### pos, adj를 동시에 지정하면 pos가 우선
plot(1:6 ,1:6)
text(2,1, "Hi")
text(3,2, "Go")
text(4,4, "00", adj=c(0,0)
### text() : 그래프에 문자열을 그리는데 사용하는 함수
### pos는 텍스트의 좌표를 지정
### 1:좌표의 하단, 2:좌표의 좌측, 3:좌표의 상단, 4:좌표의 우측
### adj는 텍스트의 위치를 지정
### (0,0):우측 상단, (0,1):우측 하단, (1,0):좌측 상단, (1,1):좌측 하단
### pos, adj를 동시에 지정하면 pos가 우선
plot(1:6 ,1:6)
text(2,1, "Hi")
text(3,2, "Go")
text(4,4, "00", adj=c(0,0))
text(4,4, "01", adj=c(0,1))
text(4,4, "01", adj=c(1,0))
text(4,4, "01", adj=c(1,1))
### text() : 그래프에 문자열을 그리는데 사용하는 함수
### pos는 텍스트의 좌표를 지정
### 1:좌표의 하단, 2:좌표의 좌측, 3:좌표의 상단, 4:좌표의 우측
### adj는 텍스트의 위치를 지정
### (0,0):우측 상단, (0,1):우측 하단, (1,0):좌측 상단, (1,1):좌측 하단
### pos, adj를 동시에 지정하면 pos가 우선
plot(1:6 ,1:6)
text(2,1, "Hi")
text(3,2, "Go")
text(4,4, "00", adj=c(0,0))
text(4,4, "01", adj=c(0,1))
text(4,4, "10", adj=c(1,0))
text(4,4, "11", adj=c(1,1))
# 데이터 순서에 따라 번호를 붙임
plot(Orange$age, Orange$circumference, cex=1)
text(Orange$age, Orange$circumference, pos=4)
### identify() : 그래프를 그린 뒤 표현된 산점도의 점을 식별하는 함수
### plot()으로 그래프를 그리고 identify()함수를 실행하면 그림 2와 같이 마우스 아이콘이 십자커서(+) 형태로 표현됨
### 마우스로 그래프에 점을 찍고 ESC로 명령어를 종료하면 찍었던 점에 대한 데이터를 식별해줌
plot(Orange$age, Orange$circumference, cex = 2)
identify(Orange$age, Orange$circumference)
### identify() : 그래프를 그린 뒤 표현된 산점도의 점을 식별하는 함수
### plot()으로 그래프를 그리고 identify()함수를 실행하면 그림 2와 같이 마우스 아이콘이 십자커서(+) 형태로 표현됨
### 마우스로 그래프에 점을 찍고 ESC로 명령어를 종료하면 찍었던 점에 대한 데이터를 식별해줌
plot(Orange$age, Orange$circumference, cex = 2)
identify(Orange$age, Orange$circumference)
### legend() : 범례를 표시해주는 함수
plot(iris$Sepal.Length, iris$Sepal.Width, cex = 2, pch=20)
points(iris$Petal.Length, iris$Petal.Width, cex = 2, pch= "+", col"#FF0000")
### legend() : 범례를 표시해주는 함수
plot(iris$Sepal.Length, iris$Sepal.Width, cex = 2, pch=20)
points(iris$Petal.Length, iris$Petal.Width, cex = 2, pch= "+", col"#FF0000")
points(iris$Petal.Length, iris$Petal.Width, cex = 2, pch= "+", col="#FF0000")
legend("topright", legend=c("Sepal", "Petal"), pch = c(20, 43),
col = c("black", "red"))
### 각각 plot(), lines(), points() 함수와 유사하지만 행렬 형태로 주어진 데이터를 그래프에 그린다는 것이 차이점
### 함수 호출 방식도 큰 차이가 없고, 다만 입력이 행렬로 주어지기만 하면 됨
###[-3pi, 3pi]구간에서의 sin(x), cos(x) 그래프 그리기
x <- seq(-3*pi, 3*pi, 0.01)
y <- matrix(c(sin(x), cos(x)), ncol = 2)
head(x, 50L)
head(y, 50L)
### matplot()에 x, y를 지정해 그래프를 그림
### abline()함수의 x=0, y=0 축을 그리기 위해 h = 0, v = 0 수행
matplot(x, y, lty = c("solid", "dashed"), cex=.5, type = "l")
abline(h = 0, v = 0)
### 1.boxplot() : 상자 그림을 그리며, 데이터의 분포를 보여줌
### 그래프의 점들은 이상치(outlier)에 해당
boxplot(cars$dist)
### 2.hist() : 값의 범위를 빈도로 표현한 히스토그램을 그리는 함수
hist(cars$dist)
### hist()표현시 세로는 빈도(데이터의 개수)를 의미하며, 밀도로 확인하고 싶다면freq옵션을 False로 수행
hist(cars$dist, freq = FALSE)
x <- hist(cars$dst, freq = FALSE)
X
x
x <- hist(cars$dst, freq = FALSE)
x <- hist(cars$dist, freq = FALSE)
x
sum(x$density) * 20
### 2.density() : 막대의 너비를 가정하지 않고 모든 점에서 데이터의 밀도를 추정하는 커널 밀도를 추정
plot(density(cars$dist))
### plot()대신 lines()를 사용하여 히스토그램 위에 밀도 선 표현가능
hist(cars$dist, freq = FALSE)
lines(density(cars$dist))
### 3.barplot : 막대 그래프를 그리는 함수
### Orange 데이터의 둘레(Circumference)값을 출력하고, x축의 값을 막대 그래프로 그린 예
barplot(Orange$circumference, names.arg = Orange$circumference)
### Orange 데이터의 둘레(Circumference)평균값을 Tree 별로 계산하고, x축의 값을 막대 그래프로 그린 예
barplot(tapply(Orange$circumference, Orange$Tree, mean), names.arg = Orange$Tree)
### Orange 데이터의 둘레(Circumference)평균값을 Tree 별로 계산하고, x축의 값을 막대 그래프로 그린 예
barplot(tapply(Orange$circumference, Orange$Tree, mean), names.arg = Orange$tree)
### 4.pie() : 데이터의 비율을 표현하는 목적으로 사용되는 함수
### 1을 10번 반복하여, 색깔을 10단계로 나눠서pie로 출력
pie(rep(1, 10), col = rainbow(10))
### 2019년 스마트폰 판매율을 pie 그래프로 표현하는 예제
slice <- c(19.2, 15.7, 11.9, 7.9, 7.3, 37.9)
name <- c("Samsung", "Huawei", "Apple", "OPPO", "Vivo", "Other")
### 2019년 스마트폰 판매율을 pie 그래프로 표현하는 예제
slices <- c(19.2, 15.7, 11.9, 7.9, 7.3, 37.9)
name <- c("Samsung", "Huawei", "Apple", "OPPO", "Vivo", "Other")
pie(slices, )
pie(slices, labels = name, main="Smartphone sales rate in 2019")
### cars데이터에서 speed와 dist의 산점도 행렬을 그리는 예
pairs(cars)
### cars데이터에서 speed와 dist의 산점도 행렬을 그리는 예
### 앞서 배웠던 pch를 사용하여 서로 다른 점 모양 표현이 가능
pairs(cars, pch = c(1,2))
### iris 데이터에서 각 종뵬(setosa, versicolor, virginica)로 Sepal.Width, Sepal.Length, Petal.Width, Petal.Length의 산점도 행렬을 그리는 예제
pairs(~ Sepal.width + Sepal.Length + Petal.Width + Petal.Length, data = iris, pch = c(10, 15, 20)[iris$Species])
### iris 데이터에서 각 종뵬(setosa, versicolor, virginica)로 Sepal.Width, Sepal.Length, Petal.Width, Petal.Length의 산점도 행렬을 그리는 예제
pairs(~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, data = iris, pch = c(10, 15, 20)[iris$Species])
# 빅데이터 분석 및 시각화 실습 1
# 서울시 공공와이파이 위치정보가 담긴 wifi.csv 파일을 활용
# 작업 위치 설정 및 확인
getwd()
# 빅데이터 분석 및 시각화 실습 1
# 서울시 공공와이파이 위치정보가 담긴 wifi.csv 파일을 활용
# 작업 위치 설정 및 확인
setwd("C:\Yoongit\R_Language\R_Studio\Day03")
# 빅데이터 분석 및 시각화 실습 1
# 서울시 공공와이파이 위치정보가 담긴 wifi.csv 파일을 활용
# 작업 위치 설정 및 확인
setwd(C:\Yoongit\R_Language\R_Studio\Day03)
# 빅데이터 분석 및 시각화 실습 1
# 서울시 공공와이파이 위치정보가 담긴 wifi.csv 파일을 활용
# 작업 위치 설정 및 확인
setwd("C:/Yoongit/R_Language/R_Studio/Day03")
getwd()
# 필요한 패키지 설치 및 적용
install.packages("ggplot2")
install.packages("ggmap")
install.packages("stringr")
install.packages("stringr")
install.packages("stringr")
install.packages("stringr")
install.packages("dplyr")
library(ggplot2)
library(ggmap)
library(stringr)
library(dplyr)
library(dplyr)
# 파일 read및 head확인
data <- read.csv("wifi.csv", header = T)
head(data)
# 파일 read및 head확인
data <- read.csv("wifi.csv", header = T, fileEncoding = "euc-kr")
head(data)
# 필요한 열만 정제(지역명, 설치위치(위도, 경도))
data2 <-data[,c(1,4,5)]
head(data2)
# data2의 열 이름 변경
names(data2) <-c("name", "lon", "lat")
head(data2)
# 이름이 동작구인 부분만 필터링
data3 <- data2 %>% filter(
name == "동작구"
)
# qmplot 함수를 이용하며, 경도, 위도에 필요한 데이터는 data3를 이용하고, maptype은 toner-lite,
# 지도에 표기할 와이파이 지점의 점은 빨간색으로 표기
qmplot(lon, lat, data = data3, maptype = "toner-lite", color = I("red"))
